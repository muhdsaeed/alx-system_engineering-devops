 
A process in Linux is nothing but a program in execution. It’s a running instance of a program. Any command that you execute starts a process.
Types of Processes in Linux
In Linux processes can be of two types:
•	Foreground Processes
depend on the user for input
also referred to as interactive processes
•	Background Processes
run independently of the user
referred to as non-interactive or automatic processes
Process States in Linux
A process in Linux can go through different states after it’s created and before it’s terminated. These states are:
•	Running
•	Sleeping
•	Interruptible sleep
•	Uninterruptible sleep
•	Stopped
•	Zombie
•	A process in running state means that it is running or it’s ready to run.
•	The process is in a sleeping state when it is waiting for a resource to be available.
•	A process in Interruptible sleep will wakeup to handle signals, whereas a process in Uninterruptible sleep will not.
•	A process enters a stopped state when it receives a stop signal.
•	Zombie state is when a process is dead but the entry for the process is still present in the table.
Different Commands for Process Management in Linux
There are two commands available in Linux to track running processes. These two commands are Top and Ps.
1. The top Command for Mananging Linux Processes
To track the running processes on your machine you can use the top command.
$ top 
Copy
 
Top command displays a list of processes that are running in real-time along with their memory and CPU usage. Let’s understand the output a little better:
•	PID: Unique Process ID given to each process.
•	User: Username of the process owner.
•	PR: Priority given to a process while scheduling.
•	NI: ‘nice’ value of a process.
•	VIRT: Amount of virtual memory used by a process.
•	RES: Amount of physical memory used by a process.
•	SHR: Amount of memory shared with other processes.
•	S: state of the process
•	‘D’ = uninterruptible sleep
•	‘R’ = running
•	‘S’ = sleeping
•	‘T’ = traced or stopped
•	‘Z’ = zombie
•	%CPU: Percentage of CPU used by the process.
•	%MEM; Percentage of RAM used by the process.
•	TIME+: Total CPU time consumed by the process.
•	Command: Command used to activate the process.
You can use the up/down arrow keys to navigate up and down through the list. To quit press q. To kill a process, highlight the process with the up/down arrow keys and press ‘k’.




SIGNALS
A signal is an event generated by the UNIX and Linux systems in response to some condition. Upon receipt of a signal, a process may take action.

A signal is just like an interrupt; when it is generated at the user level, a call is made to the kernel of the OS, which then acts accordingly.

There are two types of signals:

Maskable: signals which can be changed or ignored by the user (e.g., Ctrl+C).
Non-Maskable: signals which cannot be changed or ignored by the user. These typically occur when the user is signaled for non-recoverable hardware errors.





Signals List
The table below contains some common signals and their associated meanings.
Signal	Description
SIGHUP	Hang-up detected on controlling terminal or death of controlling process.
SIGINT	Issued if the user sends an interrupt signal (Ctrl + C).
	
SIGQUIT	Issued if the user sends a quit signal (Ctrl + D).
	
SIGFPE	Issued if an illegal mathematical operation is attempted.
	
SIGKILL	If a process gets this signal, it must quit immediately and will not perform any clean-up operations.
SIGTERM	Software termination signal (sent kill by default).
	
SIGALRM	Alarm clock signal (used for timers).

	


